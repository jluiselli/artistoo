<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Mitochondria</title>
<style type="text/css">
body{
		font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue",
		 Helvetica, Arial, "Lucida Grande", sans-serif;
	 padding : 15px;
}
td {
	 padding: 10px;
	 vertical-align: top;
}
</style>


<script src="./artistoo.js"></script>
<script src="./fpsmeter.min.js"></script>
<script src="./colormap.js"></script>

<script>
"use strict"


/*	----------------------------------
	CONFIGURATION SETTINGS
	----------------------------------
*/
let config = {

	// Grid settings
	ndim : 2,
	field_size : [150,150],
	
	// CPM parameters and configuration
	conf : {
		// Basic CPM parameters
		torus : [false,false],				// Should the grid have linked borders?
		seed : 5,							// Seed for random number generation.
		T : 2,								// CPM temperature
        
        // used internally
		CELLS : ["empty", CPM.Mitochondrion],
        NOISE : 5,
        N_OXPHOS : 5, 
        N_TRANSLATE : 10,
        N_REPLICATE : 100,
        INIT_OXPHOS : 80,
        N_INIT_DNA : 10,
		MTDNA_MUT_RATE : 0.5,

		// Constraint parameters. 
		// Mostly these have the format of an array in which each element specifies the
		// parameter value for one of the cellkinds on the grid.
        // First value is always cellkind 0 (the background) and is often not used.
        
		// division_volume : [0, 200],
		minimal_division_volume : 150,
		division_rate : 0.01,
		fusion_rate : 0.1,
		deprecation_rate : 0.05,
		replication_rate : 0.5,
		translation_rate: 0.5,
        MITO_SHRINK : 6,
        
        // Adhesion parameters:
         J: [ [15,15], 
			[15,15], // epidermal cells
		 ],
		
		
		// VolumeConstraint parameters
		LAMBDA_V : [0, 1],				// VolumeConstraint importance per cellkind
		V : [0,152]					// Unused - are backup.
		
	},
	
	// Simulation setup and configuration: this controls stuff like grid initialization,
	// runtime, and what the output should look like.
	simsettings : { 
	
		// Cells on the grid
		NRCELLS : [10],						// Number of cells to seed for all
		// non-background cellkinds. 
		// Runtime etc
		BURNIN : 100,
		RUNTIME : 1000,
		RUNTIME_BROWSER : "Inf",
		
		// Visualization
		CANVASCOLOR : "EEEEEE",
		CELLCOLOR : ["AA111A","FFA110"],
		SHOWBORDERS : [true, true],				// Should cellborders be displayed?
		BORDERCOL : ["666666", "666666"],				// color of the cell borders
		zoom : 3,							// zoom in on canvas with this factor.
		
		// Output images
		SAVEIMG : true,						// Should a png image of the grid be saved
		// during the simulation?
		IMGFRAMERATE : 1,					// If so, do this every <IMGFRAMERATE> MCS.
		SAVEPATH : "output/img/CellDivision",	// ... And save the image in this folder.
		EXPNAME : "CellDivision",					// Used for the filename of output images.
		
		// Output stats etc
		STATSOUT : { browser: false, node: true }, // Should stats be computed?
		LOGRATE : 10							// Output stats every <LOGRATE> MCS.

	}
}
/*	---------------------------------- */
let sim, meter, colorby, cellColors

function initialize(){
	 /* 	The following functions are defined below and will be added to
	 	the simulation object. If Custom-methods above is set to false,
	 	this object is ignored and not used in the html/node files. */
	 let custommethods = {
	 	postMCSListener : postMCSListener,
		initializeGrid : initializeGrid,
		drawCanvas : drawCanvas
	 }
	sim = new CPM.Simulation( config, custommethods )

	colorby = "n_DNA"

	meter = new FPSMeter({left:"auto", right:"5px"})

	step()
}


function step(){
	sim.step()
	meter.tick()
	if( sim.conf["RUNTIME_BROWSER"] == "Inf" | sim.time+1 < sim.conf["RUNTIME_BROWSER"] ){
		requestAnimationFrame( step )
	}
}



/* The following custom methods will be added to the simulation object*/
function postMCSListener(){
	
	// add the initializer if not already there
	if( !this.helpClasses["gm"] ){ this.addGridManipulator() }
	
	var C = this.C
	this.C.cells.forEach(function (item) {
		// console.log("volumes: ", C.cellvolume[item.id], C.getVolume(item.id))
		update(C, item)
	});
	for( let i of this.C.cellIDs() ){
		if( this.C.getVolume(i) > this.C.conf.minimal_division_volume && this.C.random() < this.C.conf["division_rate"]){
			this.gm.divideCell(i)
		}
	}
}

function findDNA(mito) {
	if (mito.DNA.length == 0 ){ return }
    // takes bottleneck as rate
    var replicate_attempts = Math.min.apply(Math, mito.replication_products) 
    var translate_attempts = Math.min.apply(Math, mito.translate_products)
    var attempts = replicate_attempts + translate_attempts

    // replication and translation machinery try to find DNA to execute on
    while (attempts > 0){
        // console.log(replicate_attempts, translate_attempts, attempts)
        if (mito.mt.random() < replicate_attempts/attempts){
            // attempt to find a DNA to replicate
            let ix = Math.floor(mito.mt.random() * mito.DNA.length)
            if (mito.DNA[ix].notBusy()){ 
                mito.DNA[ix].setReplicateFlag(true)
            }
            replicate_attempts--
            attempts--
        } else {
            // console.log("SETTING TRANSLATEFLAG")
            // attempt to translate
            let ix = Math.floor(mito.mt.random() * mito.DNA.length)
            if (mito.DNA[ix].notBusy()){
                mito.DNA[ix].setTranslateFlag(true)
            }
            translate_attempts-- //technically redundant
            attempts--
        }
    }
}

function sumArray(array1, array2){
	return array1.map(function (num, idx) {
  		return num + array2[idx];
	})
}

function repAndTranslate(mito){
	for (var dna of mito.DNA){
    //    console.log(dna.translateFlag)
        if (dna.translateFlag){
            // console.log( "translating")
			// console.log(dna.oxphos_quality, mito.oxphos_products)
			if (mito.mt.random() < mito.conf['translation_rate']){
				mito.oxphos_products = sumArray(mito.oxphos_products, dna.oxphos_quality)
				mito.translate_products = sumArray(mito.translate_products, dna.translate_quality)
				mito.replication_products = sumArray(mito.replication_products, dna.replicate_quality)
			}
            dna.setTranslateFlag(false)
        } else if (dna.replicateFlag) { 
			// console.log( "replicating")
			if (mito.mt.random() < mito.conf['replication_rate']){
				mito.replicateDNA(dna)
			}
            dna.setReplicateFlag(false)
        }
	}
}

function deprecateProducts(mito){
	let new_arr = [[], [], []]
	for (const [which, arr] of [mito.oxphos_products, mito.translate_products, mito.replication_products].entries()){
		new_arr[which] = [...arr]
		for (const [ix, product] of arr.entries()){
			let i = 0
			for (let i = 0; i < product; i++ ){
				if (mito.mt.random() < mito.conf['deprecation_rate']){new_arr[which][ix]--;}
			}
		}
	}
	mito.setProducts(new_arr[0], new_arr[1], new_arr[2])
}

function update(C, mito, total_oxphos, total_growth_cap){
	if (mito.id < 0){return}
	// console.log("oxphos: ", mito.oxphos, "n DNA: ", mito.DNA.length, "heteroplasmy", mito.heteroplasmy(), "hei", Math.min.apply(Math, mito.replication_products) )
	mito.oxphos = Math.min.apply(Math, mito.oxphos_products) 
	console.log("oxphos: ", mito.oxphos, "n DNA: ", mito.DNA.length, "heteroplasmy", mito.heteroplasmy(), "replication:", Math.min.apply(Math, mito.replication_products), mito.oxphos_products, mito.id, C.getVolume(mito.id) )
	total_oxphos += mito.oxphos
    if (mito.V - C.getVolume(mito.id) < 10){
        mito.V += Math.max(mito.oxphos / 10, 10)
	}
	if (mito.oxphos < 20) {
		mito.V -= 20
	}
    // mito.V -= mito.conf["MITO_SHRINK"]
    total_growth_cap += mito.V
	findDNA(mito)

	repAndTranslate(mito)

	deprecateProducts(mito)


	
}
// function updateCell(C, cell){
// 	if (cell.id < 0){return}
//     let vol = C.getVolume(cell.id)
//     // console.log(cell.X, " ",cell.Y, " ", cell.V)
//     let V = cell.V
//     if ((cell.V - vol) < 10 && cell.X > 0){
//         V += C.conf.y_growth_contribution[cell.kind]*(cell.Y/vol)/((cell.Y/vol)+0.1)
        
//     }
//     V -= C.conf.shrink_rate[cell.kind]
//     cell.setV(V)
    
//     let dy = C.conf.rY[cell.kind]*cell.Y*(vol-cell.X-cell.Y)/vol*C.conf.speed_internal_dynamics[cell.kind]
//     let X = cell.X + (1-C.conf.Q[cell.kind])*dy+( C.conf.rX[cell.kind]*cell.X*(vol-cell.X-cell.Y)/vol - C.conf.d[cell.kind]*cell.X )*C.conf.speed_internal_dynamics[cell.kind]
//     let Y = cell.Y + C.conf.Q[cell.kind]*dy - C.conf.d[cell.kind]*cell.Y*C.conf.speed_internal_dynamics[cell.kind]
// 	cell.setXY(X,Y)
// }

function initializeGrid(){
	
	// add the initializer if not already there
	if( !this.helpClasses["gm"] ){ this.addGridManipulator() }
    
	let nrcells = this.conf["NRCELLS"], cellkind, i
		
	// Seed the right number of cells for each cellkind 
	for( cellkind = 0; cellkind < nrcells.length; cellkind ++ ){
		
		for( i = 0; i < nrcells[cellkind]; i++ ){
			// first cell always at the midpoint. Any other cells
			// randomly.				
			if( i == 0 ){
                this.gm.seedCellAt( cellkind+1, [this.C.midpoint[0]/2, this.C.midpoint[1] ] )
			} else {
				this.gm.seedCell( cellkind+1 )
			}
		}
	}
}


// Custom drawing function to draw the preferred directions.
function drawCanvas(){
	
	/* This part is the normal drawing function */
	
	// Add the canvas if required

	if( !this.helpClasses["canvas"] ){ this.addCanvas() }

	// Clear canvas
	this.Cim.clear( this.conf["CANVASCOLOR"] || "FFFFFF" )
		
	// Draw each cellkind appropriately
	console.log(colorby)
	
	if (colorby == "Cell_type"){
			// Draw each cellkind appropriately
			let cellcolor=this.conf["CELLCOLOR"], 
		nrcells=this.conf["NRCELLS"], cellkind, cellborders = this.conf["SHOWBORDERS"]
		for( cellkind = 0; cellkind < nrcells.length; cellkind ++ ){
		
		// draw the cells of each kind in the right color
		if( cellcolor[ cellkind ] != -1 ){
			this.Cim.drawCells( cellkind+1, cellcolor[cellkind] )
		}
			
		// Draw borders if required
		if(  cellborders[ cellkind  ]  ){
			this.Cim.drawCellBorders( cellkind+1, "000000" )
		}
	}
	} else {
		// Function to color cells as function of their cellID number.
		// we need a trick because otherwise 'this' (the simulation object)
		// is not available from the colFun() function.
		let s = this
		let colFun = function( cid ){

			// First time function is called, attach an empty object 'cellColors' to
			// simulation object; this tracks the color for each cellID on the grid.
			if( !s.hasOwnProperty( cellColors ) ){
				s.cellColors = {}
			}
			// Check if the current cellID already has a color, otherwise put a random
			// color in the cellColors object
			if( !s.cellColors.hasOwnProperty(cid) ){
				s.cellColors[cid] = getColor(s.C.cells[cid])
			}

			// now return the color assigned to this cellID.
			return s.cellColors[cid]
		}
		let nrcells=this.conf["NRCELLS"], cellkind, cellborders = this.conf["SHOWBORDERS"]
		for( cellkind = 0; cellkind < nrcells.length; cellkind ++ ){
			this.Cim.drawCells( cellkind+1, colFun)

			// Draw borders if required
			if(  cellborders[ cellkind  ]  ){
				this.Cim.drawCellBorders( cellkind+1, "000000" )
			}
		}
	} 	
}

const cmap = new ColorMap({
		colormap: 'bluered',
		nshades: 100,
		format: 'hex',
		alpha: 1
})

function getColor (cell) {
	if (cell.id < 0){
		return
	}
	var c = 0
	if (colorby == 'n_DNA'){
		c = Math.floor(cell.DNA.length *4) 
	} else if  (colorby == 'heteroplasmy'){
		c = Math.floor(cell.heteroplasmy() *100)
	} else if (colorby == 'oxphos'){
		c = Math.floor(cell.oxphos)
	}
	if (c >= cmap.length){
		c = cmap.length - 1
	} else if (c < 0){
		c = 0
	}
	if (cmap[c] === undefined){
		console.log("HEY", cell.V, cell.id, c,)
	}
	return cmap[c].substring(1)
}

function changeColorBy(){
	var radios = document.getElementsByName('Visualization');
	for (var i = 0, length = radios.length; i < length; i++) {
		if (radios[i].checked) {
			colorby = radios[i].value
			break;
		}
	}
}


</script>
</head>
<body onload="initialize()">
<h1>Stochastic Correction</h1>

<input type="radio" name="Visualization" value="Cell_type" >Cell Type (fastest)<br>
<input type="radio" name="Visualization" value="n_DNA" checked>Number of DNA copies<br>
<input type="radio" name="Visualization" value="oxphos" checked>Oxphos<br>
<input type="radio" name="Visualization" value="heteroplasmy">Heteroplasmy<br>
<div>
    <button type="submit" onclick="changeColorBy()">Submit</button>
  </div>


<p>
 Replicator and mutant RNA compete in vesicles
</p>
</body>
</html>
