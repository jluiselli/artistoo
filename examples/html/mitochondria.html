<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Mitochondria</title>
<style type="text/css">
body{
		font-family: "MS Comic Sans", "Helvetica Neue Light", "Helvetica Neue",
		 Helvetica, Arial, "Lucida Grande", sans-serif;
	 padding : 15px;
}
td {
	 padding: 10px;
	 vertical-align: top;
}
</style>


<script src="./artistoo.js"></script>
<script src="./fpsmeter.min.js"></script>

<script>
"use strict"


/*	----------------------------------
	CONFIGURATION SETTINGS
	----------------------------------
*/
let config = {

	// Grid settings
	ndim : 2,
	field_size : [150,150],
	
	// CPM parameters and configuration
	conf : {
		// Basic CPM parameters
		torus : [true,true],				// Should the grid have linked borders?
		seed : 3,							// Seed for random number generation.
		T : 20,								// CPM temperature
        
    
		CELLS : ["empty", CPM.HostCell, CPM.Mitochondrion], 
        
        J_INT:  [ 
			[15,15], 
            [15,1500] ],

        J_EXT:  [ [15,15,1500], 
			[1000,15,1500], 
            [1500, 1500,15000] ],

        // LAMBDA_SUB: [0, 0, 500] ,
	
        // NOISE : 5,
        N_OXPHOS : 5, 
        N_TRANSLATE : 10,
        N_REPLICATE : 100,
        INIT_OXPHOS : 40,
        N_INIT_DNA : 10,
		MTDNA_MUT_RATE : 0.1,
		INIT_HOST_V : 500,


		// Constraint parameters. 
		// Mostly these have the format of an array in which each element specifies the
		// parameter value for one of the cellkinds on the grid.
        // First value is always cellkind 0 (the background) and is often not used.
        
		// division_volume : [0, 200],
		minimal_division_volume : 150,
		fission_rate : 0.03,
		fusion_rate : 0.005,
		deprecation_rate : 0.03,
		dna_deprecation_rate :0.005,
		replication_rate : 1,
		translation_rate: 1, 
		host_selfishness : 0.6, 
		MITO_SHRINK : 0,
		MITOPHAGY_THRESHOLD: 5,
		MITOPHAGY_SHRINK : 12,
		HOST_SHRINK : 3,
		EMPTY_HOST_SHRINK: 10,
		MITO_GROWTH_MAX : 5,
		HOST_GROWTH_MAX : 5,
		MITO_V_PER_OXPHOS : 0.4,
		HOST_V_PER_OXPHOS : 0.2,

		MITO_PARTITION : 0.3,

		// VolumeConstraint parameters
		LAMBDA_V : [0, 100, 100],				// VolumeConstraint importance per cellkind
		V : [0,502, 200],					
		division_volume: [100, 800, 100]
	},
	
	// Simulation setup and configuration: this controls stuff like grid initialization,
	// runtime, and what the output should look like.
	simsettings : { 
	
		// Cells on the grid
		NRCELLS : [5, 5],						// Number of cells to seed for all
		// non-background cellkinds. 
		// Runtime etc
		BURNIN : 0,
		RUNTIME : 1000,
		RUNTIME_BROWSER : "Inf",
		
		// Visualization
		CANVASCOLOR : "EEEEEE",
		CELLCOLOR : ["9E60BE", "FFAAEA"],
		SHOWBORDERS : [true, true],				// Should cellborders be displayed?
		BORDERCOL : ["666666", "666666"],				// color of the cell borders
		zoom : 3,							// zoom in on canvas with this factor.
		
		// Output images
		SAVEIMG : true,						// Should a png image of the grid be saved
		// during the simulation?
		IMGFRAMERATE : 1,					// If so, do this every <IMGFRAMERATE> MCS.
		SAVEPATH : "output/img/CellDivision",	// ... And save the image in this folder.
		EXPNAME : "CellDivision",					// Used for the filename of output images.
		
		// Output stats etc
		STATSOUT : { browser: false, node: true }, // Should stats be computed?
		LOGRATE : 10							// Output stats every <LOGRATE> MCS.

	}
}
/*	---------------------------------- */
let sim, meter, colorby, cellColors

function initialize(){
	 /* 	The following functions are defined below and will be added to
	 	the simulation object. If Custom-methods above is set to false,
	 	this object is ignored and not used in the html/node files. */
	 let custommethods = {
	 	postMCSListener : postMCSListener,
		initializeGrid : initializeGrid,
		drawCanvas : drawCanvas
	 }
	sim = new CPM.Simulation( config, custommethods )

    sim.C.add( new CPM.SubCellConstraint( config["conf"] ) )


	changeColorBy()

	meter = new FPSMeter({left:"auto", right:"5px"})
	step()
}


function step(){
    sim.step()
    meter.tick()
    if (sim.time == 100){
        seedSubCells()
        
    }
	if( sim.conf["RUNTIME_BROWSER"] == "Inf" | sim.time+1 < sim.conf["RUNTIME_BROWSER"] ){
		requestAnimationFrame( step )
	}
}

function seedSubCells(){
    let nrcells = sim.conf["NRCELLS"][1], i
    // Only seed Supercells in initialize
    // let cellkind = 0
    if (!sim.gm){
        sim.addGridManipulator()
    } 
    let cellpixelsbyid = sim.C.getStat(CPM.PixelsByCell)
    for (let cid of Object.keys(cellpixelsbyid)) {
        if (sim.C.cellKind(cid) == 1){
            for (let i =0; i < sim.conf["NRCELLS"][1]; i++){
                let coord = cellpixelsbyid[cid][Math.floor(sim.C.mt.random()*cellpixelsbyid[cid].length)]
                let nid = sim.gm.seedCellAt( 2, coord )
				sim.C.cells[nid].host = cid
            }
        }
    }
}

/* The following custom methods will be added to the simulation object*/
function postMCSListener(){
	if (sim.time < 200){
		return
	}
	if( !this.helpClasses["gm"] ){ this.addGridManipulator() }

	let neighs = sim.C.getStat( CPM.CellNeighborList )
	
	// let all_sub = {} //sorted by host
	// let all_super = {} //cells by host
	// for (let cid of this.C.cellIDs()){
	// 	let cell = this.C.cells[cid]
	// 	if (cell instanceof CPM.SubCell){
	// 		if (!all_sub.hasOwnProperty(cell.host)){
	// 			all_sub[cell.host] = []
	// 		}
	// 		all_sub[cell.host].push(cell) 
	// 	} else if (cell instanceof CPM.SuperCell){
	// 		all_super[cid] = cell
	// 	}
	// }
	
	for (let cid of this.C.cellIDs()){
		if (this.C.cells[cid] instanceof CPM.HostCell){
			this.C.cells[cid].update()
		}
	}

	for( let cid of this.C.cellIDs() ){
		if (this.C.cells[cid] instanceof CPM.SubCell){
			if (this.C.random() < 0.002){
				let cell = this.C.cells[cid]
				console.log("n DNA: ", cell.DNA.length, "oxphos: ", cell.oxphos, "heteroplasmy: ", cell.heteroplasmy(), "DNA:" ,cell.DNA)
			}
			if (this.C.random() < this.C.conf['fission_rate'] && this.C.getVolume(cid) > this.C.conf.division_volume[this.C.cellKind(cid)]){
				let nid = this.gm.divideCell(cid, this.C.conf['MITO_PARTITION'])
				// let cell = this.C.cells[cid]
				// console.log("n DNA: ", cell.DNA.length, "oxphos: ", cell.oxphos, "heteroplasmy: ", cell.heteroplasmy(), cell.products)
				// cell = this.C.cells[nid]
				// console.log("n DNA: ", cell.DNA.length, "oxphos: ", cell.oxphos, "heteroplasmy: ", cell.heteroplasmy(), cell.products)
				// console.log("---------")
			} else {
				// console.log(neighs, cid)
				for (let neigh of Object.keys(neighs[cid])){
					// console.log(neigh)
					if (this.C.cells[neigh] instanceof CPM.Mitochondrion && this.C.random() < this.C.conf['fusion_rate']){
						this.gm.fuseCells(cid, neigh)
					}
				}
			}
		}
		if (this.C.cells[cid] instanceof CPM.SuperCell){
			if (this.C.getVolume(cid) > this.C.conf.division_volume[this.C.cellKind(cid)]){
				let nid = this.gm.divideCell(cid)
				transferSubCells(cid, nid) 
			}
		}
	}
}

function initializeGrid(){
	
	// add the initializer if not already there
	if( !this.helpClasses["gm"] ){ this.addGridManipulator() }

    let nrcells = this.conf["NRCELLS"][0], i
    // Only seed Supercells in initialize
    // let cellkind = 0
    for( i = 0; i < nrcells; i++ ){			
        if( i == 0 ){
            this.gm.seedCellAt( 1, [this.C.midpoint[0]/2, this.C.midpoint[1] ] )
        } else {
            this.gm.seedCell(1)
        }
    }
}

function euclidean(x0, y0, x1, y1){
	return Math.sqrt(Math.pow(x0-x1, 2)+Math.pow(y0-y1,2))
}

function transferSubCells (parent, child){
	let neighborlst = sim.C.getStat(CPM.CellNeighborList)
	// let centroids = sim.C.getStat( CPM.CentroidsWithTorusCorrection ) //maybe rewrite to neighborlist again
	for (let cid of sim.C.cellIDs()) {
		let cell = sim.C.cells[cid]
		if (cell instanceof CPM.SubCell && cell.host === parent){ 
			let parentlength = (neighborlst[cid][parent] || 0)
			let childlength = (neighborlst[cid][child] || 0)
			console.log(parentlength, childlength)
			if (childlength > parentlength){
				cell.host = child
			} 
			// // TODO rewrite this to neigborlength
			// console.log(neighborlst)
			// if (neighborlst[cid])
			// if (euclidean(centroids[cid][0], centroids[cid][1], centroids[child][0], centroids[child][1])
			// 		< euclidean(centroids[cid][0], centroids[cid][1], centroids[parent][0], centroids[parent][1])){
			// 			cell.host = child
			// 	}
		}
	}
}

// Custom drawing function to draw the preferred directions.
function drawCanvas(){
	if( !this.helpClasses["canvas"] ){ this.addCanvas() }
	this.Cim.clear( this.conf["CANVASCOLOR"] || "FFFFFF" )
	let nrcells=this.conf["NRCELLS"], cellkind, cellborders = this.conf["SHOWBORDERS"]

	let colfun = getColor.bind(this)
	for( cellkind = 0; cellkind < nrcells.length; cellkind ++ ){
		this.Cim.drawCells( cellkind+1, colfun)
		if(  cellborders[ cellkind  ]  ){
			this.Cim.drawCellBorders( cellkind+1, "000000" )
		}
	}
}

const cmap = new CPM.ColorMap({
		colormap: 'viridis',
		nshades: 100,
		format: 'hex', 
		alpha: 1
})

function getColor (cid) {
	let cell = this.C.cells[cid]
	if (cell.id < 0){
		return
	}
	let c = 0
	let no_cmap = false
	if (cell instanceof CPM.SuperCell){
		switch (colorby){
			case "host":
				c = Math.floor(cell.host)
				break
			default:
				no_cmap= true
				c = String(this.conf["CELLCOLOR"][cell.kind-1])
		}
	} else {
		switch (colorby){
			case "host":
				if (this.C.cells[cell.host].subcells.includes(cell)){
					c = Math.floor(cell.host)
				} else {
					c = NaN
				}
				break
			case 'n_DNA':
				c = Math.floor(cell.DNA.length) 
				break
			case 'heteroplasmy':
				c = Math.floor(cell.heteroplasmy() *100)
				break
			case 'oxphos':
				c = Math.floor(cell.oxphos)
				break
			case 'host':
				c = Math.floor(cell.host/10)
				break
			case 'kill':
				exit()
			default:
				no_cmap= true
				c = String(this.conf["CELLCOLOR"][cell.kind-1]) //very ugly!
		}
	}
	// console.log(c)
	
	if (!no_cmap){ 
		if (Number.isNaN(c)){
		return "A9A9A9"
		}
		c = Math.min(cmap.length-1, c)
		c = Math.max(1, c)
		
		c = cmap[c].substring(1)
	}
	return c
}

function changeColorBy(){
	var radios = document.getElementsByName('Visualization');
	for (var i = 0, length = radios.length; i < length; i++) {
		if (radios[i].checked) {
			colorby = radios[i].value
			break;
		}
	}
}


</script>
</head>
<body onload="initialize()">
<h1>Mitochondria</h1>

<input type="radio" name="Visualization" value="Cell_type" >Cell Type (fastest)<br>
<input type="radio" name="Visualization" value="n_DNA" >Number of DNA copies<br>
<input type="radio" name="Visualization" value="oxphos" >Oxphos<br>
<input type="radio" name="Visualization" value="heteroplasmy"checked>Heteroplasmy<br>
<input type="radio" name="Visualization" value="host" unchecked>Host<br>
<input type="radio" name="Visualization" value="kill">Kill<br>
<div>
    <button type="submit" onclick="changeColorBy()">Submit</button>
  </div>


<p>
 Cells in other cells.
</p>
</body>
</html>
